// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using AssemblyCSharp;

namespace AssemblyCSharp
{
	public class ParticleManager
	{
		private static object _lockObject = new object();

		public List<ForceBehaviourBase> Forces {
			get;
			set;
		}

		public List<ForceBehaviourBase> HintableForces {
			get
			{
				return Forces.Where(f=> !f.IsConstant && f.ShowOnItemsPanel && f.HintOrder >= 0).OrderBy(f=>f.HintOrder).ToList();
			}
		}

		public List<ParticleSystemSettingBehaviour> Particles {
			get;
			set;
		}

		public List<GoalBehaviour> Goals {
			get;
			set;
		}

		public ParticleManager ()
		{
			Forces = new List<ForceBehaviourBase>();
			Particles = new List<ParticleSystemSettingBehaviour>();
			Goals = new List<GoalBehaviour>();
		}

		public void AddParticleSystem(ParticleSystemSettingBehaviour setting){
			lock (_lockObject) {
				if(!Particles.Contains(setting))
					Particles.Add(setting);
			}
		}

		public void AddForce(ForceBehaviourBase setting){
			lock (_lockObject) {
				if(!Forces.Contains(setting))
					Forces.Add(setting);
			}
		}

		public void AddGoal (GoalBehaviour goalBehaviour)
		{			
			lock (_lockObject) {
				if(!Goals.Contains(goalBehaviour))
					Goals.Add(goalBehaviour);
			}		
		}

		public void ClearAll(){
			Particles.Clear();
			Forces.Clear();
			Goals.Clear();
		}

		public void Apply()
		{
			var removedParticles = new List<int>();

			for (int p = 0; p < Particles.Count; p++)
			{
				if(Particles[p] == null || Particles[p].MainEmitter == null)
					return;

				ParticleSystem.Particle[] currentParticles = new ParticleSystem.Particle[Particles[p].MainEmitter.particleCount];
				Particles[p].MainEmitter.GetParticles(currentParticles);

				for (int cp = 0; cp < currentParticles.Length; cp++)
				{

					// apply forces
					for (int f = 0; f < Forces.Count; f++)
					{
						if(Forces[f].ForceInstance == null)
							continue;

						if(!Forces[f].ShowOnItemsPanel || Forces[f].IsVisible)
						{
							Forces[f].ForceInstance.Apply(
															Forces[f].transform.position, 
															currentParticles[cp].position,
															ref currentParticles[cp]
														);
						}
					}

					// invoke goals
					for (int i = 0; i < Goals.Count; i++) {
						var applied = Goals[i].Apply(currentParticles[cp]);
						if(applied)
						{
							removedParticles.Add(cp);
						}
					}
				}

				// remove flagged particles
				if(removedParticles.Count>0)
				{
					var newParticles = new ParticleSystem.Particle[currentParticles.Length - removedParticles.Count];
					var newParticlesCounter = 0;

					for (int cp = 0; cp < currentParticles.Length; cp++) {
						var isCurrentParticleRemoved = removedParticles.Contains(cp);

						if(!isCurrentParticleRemoved)
						{
							newParticles[newParticlesCounter++] = currentParticles[cp];
						}
					}

					currentParticles = newParticles;
					removedParticles.Clear();
				}


				Particles[p].MainEmitter.SetParticles(currentParticles, currentParticles.Length);
			}

		}
	}
}